number_of_philosophers time_to_die time_to_eat time_to_sleep [number_of_times_each_philosopher_must_eat]

◦ timestamp_in_ms X has taken a fork 
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died

memset, printf, malloc, free, write,
usleep, gettimeofday, pthread_create,
pthread_detach, pthread_join, pthread_mutex_init,
pthread_mutex_destroy, pthread_mutex_lock,
pthread_mutex_unlock

Tant que philosophe est en vie
{
	prendre fourchette 1 puis fourchette 2 (i + 1 pour les paires, i pour les impair)
}

Bien sûr, voici les descriptions mises à jour avec les valeurs de retour des fonctions :

1. **memset**
   - **Utilisation** : Initialise un bloc de mémoire avec une valeur spécifique.
   - **Prototype** : `void *memset(void *s, int c, size_t n);`
   - **Description** : Remplit les `n` premiers octets de la zone mémoire pointée par `s` avec l'octet `c`.
   - **Valeur de retour** : Retourne un pointeur sur la zone mémoire `s`.

2. **pthread_create**
   - **Utilisation** : Crée un nouveau thread.
   - **Prototype** : `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);`
   - **Description** : Initialise un thread qui exécute la fonction `start_routine` avec l'argument `arg`.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

3. **pthread_detach**
   - **Utilisation** : Détache un thread, permettant la libération automatique de ses ressources à la fin de son exécution.
   - **Prototype** : `int pthread_detach(pthread_t thread);`
   - **Description** : Une fois détaché, le thread ne peut plus être rejoint avec `pthread_join`.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

4. **pthread_join**
   - **Utilisation** : Attend la fin d'un thread.
   - **Prototype** : `int pthread_join(pthread_t thread, void **retval);`
   - **Description** : Bloque l'appelant jusqu'à ce que le thread spécifié se termine. `retval` peut être utilisé pour récupérer la valeur de retour du thread.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

5. **pthread_mutex_init**
   - **Utilisation** : Initialise un mutex.
   - **Prototype** : `int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);`
   - **Description** : Prépare un mutex pour être utilisé. `attr` peut spécifier des attributs particuliers, mais est généralement `NULL` pour des valeurs par défaut.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

6. **pthread_mutex_destroy**
   - **Utilisation** : Détruit un mutex.
   - **Prototype** : `int pthread_mutex_destroy(pthread_mutex_t *mutex);`
   - **Description** : Libère les ressources associées à un mutex. Le mutex ne doit pas être verrouillé lors de l'appel.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

7. **pthread_mutex_lock**
   - **Utilisation** : Verrouille un mutex.
   - **Prototype** : `int pthread_mutex_lock(pthread_mutex_t *mutex);`
   - **Description** : Bloque l'appelant si le mutex est déjà verrouillé, jusqu'à ce qu'il puisse obtenir le verrou.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

8. **pthread_mutex_unlock**
   - **Utilisation** : Déverrouille un mutex.
   - **Prototype** : `int pthread_mutex_unlock(pthread_mutex_t *mutex);`
   - **Description** : Libère le verrou sur le mutex, permettant à d'autres threads de l'obtenir.
   - **Valeur de retour** : Retourne 0 en cas de succès, ou un code d'erreur non nul en cas d'échec.

Ces valeurs de retour permettent de vérifier le succès ou l'échec des appels de fonction et de gérer les erreurs de manière appropriée.